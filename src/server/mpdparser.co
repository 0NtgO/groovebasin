{EventEmitter} = require 'events'
{trackNameFromFile} = require './futils'

function noop ({err})
  throw err if err

function parseMaybeUndefNumber (n)
  n = parseInt(n, 10)
  n = null if isNaN(n)
  n

function splitOnce (line, separator)
  index = line.indexOf(separator)
  [line.substr(0, index), line.substr(index + separator.length)]

function parseMpdObject (msg)
  # no dict comprehensions :(
  # https://github.com/satyr/coco/issues/102
  o = {}
  for [key, val] of (splitOnce(line, ": ") for line of msg.split("\n"))
    o[key] = val
  o

function parseWithSepField (msg, sep_field, skip_fields, flush)
  if msg is ""
    return []

  current_obj = null
  !function flushCurrentObj
    if current_obj?
      flush(current_obj)
    current_obj := {}
  for line of msg.split("\n")
    [key, value] = splitOnce(line, ': ')
    continue if key in skip_fields
    flushCurrentObj() if key is sep_field
    current_obj[key] = value
  flushCurrentObj()

function parseMpdTracks (msg, flush)
  parseWithSepField(msg, 'file', 'directory': true, flush)

parseMsgToTrackObjects = (msg) ->
  tracks = []
  parseMpdTracks msg, !(mpd_track) ->
    artist_name = (mpd_track.Artist ? "").trim!
    track =
      file: mpd_track.file
      name: mpd_track.Title or trackNameFromFile(mpd_track.file)
      artist_name: artist_name
      artist_disambiguation: ""
      album_artist_name: mpd_track.AlbumArtist or artist_name
      album_name: (mpd_track.Album ? "").trim!
      track: parseMaybeUndefNumber(mpd_track.Track)
      time: parseInt(mpd_track.Time, 10)
      year: parseMaybeUndefNumber(mpd_track.Date)
    tracks.push track
  tracks

module.exports = class MpdParser extends EventEmitter
  (@mpd_socket) ~>
    super()

    @mpd_socket.on \data, !(data) ~> @receive data

    @buffer = ""
    @msg_handler_queue = []
    # whether we've sent the idle command to mpd
    @idling = false

  sendRequest: !(command, cb=noop) ->
    @send "noidle\n" if @idling
    @sendWithCallback command, !(response) ~> cb @parseResponse command, response
    @sendWithCallback "idle", @~handleIdleResultsLoop
    @idling = true # we're always idling after the first command.

  parseResponse: (complete_command, response) ->
    {err, msg} = response
    return response if err?
    command_name = complete_command.match(/^\S*/)[0]
    msg: switch command_name
      case 'listallinfo'  then parseMsgToTrackObjects(msg)
      case 'lsinfo'       then parseMsgToTrackObjects(msg)[0]
      case 'status'       then parseMpdObject msg
      case 'playlistinfo'
        items = []
        parseMpdTracks msg, (track) ->
          items.push {id: parseInt(track.Id, 10), file: track.file}
        items
      case 'currentsong'
        item = null
        parseMpdTracks msg, (track) ->
          item := {id: parseInt(track.Id, 10), pos: parseInt(track.Pos, 10), file: track.file}
        item
      default msg

  send: !(data) ->
    @mpd_socket.write data

  handleMessage: !(arg) ->
    @msg_handler_queue.shift! arg

  receive: !(data) ->
    @buffer += data

    for ever
      m = @buffer.match(/^(OK|ACK|list_OK)(.*)$/m)
      return if not m?

      msg = @buffer.substring(0, m.index)
      [line, code, str] = m
      if code is "ACK"
        @emit 'error', str
        err = new Error(str)
        @handleMessage {err}
      else if line.indexOf("OK MPD") is 0
        void # new connection
      else
        @handleMessage {msg}
      @buffer = @buffer.substring(msg.length+line.length+1)

  handleIdleResults: !(msg) ->
    systems = []
    for system of msg.trim!.split("\n")
      if system.length > 0
        systems.push system.substring(9)
    @emit \status, systems if systems.length

  sendWithCallback: !(cmd, cb=noop) ->
    @msg_handler_queue.push cb
    @send "#cmd\n"

  handleIdleResultsLoop: !(arg) ->
    {err, msg} = arg
    if err then throw err
    @handleIdleResults(msg)
    # if we have nothing else to do, idle.
    if @msg_handler_queue.length is 0
      @sendWithCallback "idle", @~handleIdleResultsLoop

