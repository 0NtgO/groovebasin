{EventEmitter} = require 'events'

command_permissions =
  addid: \add
  clear: \control
  currentsong: \read
  deleteid: \control
  listallinfo: \read
  listplaylist: \read
  listplaylists: \read
  lsinfo: \read
  move: \control
  next: \control
  password: null
  pause: \control
  play: \control
  playid: \control
  playlistadd: \add
  playlistinfo: \read
  previous: \control
  repeat: \control
  seekid: \control
  setvol: \control
  shuffle: \control
  status: \read
  sticker: \admin
  stop: \control

function qEscape (str)
  # replace all " with \"
  str.toString().replace /"/g, '\\"'

module.exports = class PlayerServer extends EventEmitter
  (@library, @parser, @authenticate) ~>
    @parser.on \status, !(systems) ~>
      console.log 'changed systems:', systems
      refresh_mpd_status = false
      client_systems = []
      for system of systems
        if system of <[stored_playlist sticker]>
          # eventually the client won't need to know about these
          client_systems.push system
        else if system of <[playlist player mixer options]>
          refresh_mpd_status = true
      @emit \status, client_systems if client_systems.length
      @refreshMpdStatus! if refresh_mpd_status
    @parser.on \error, !(msg) ~>
      console.error "mpd error:", msg

    @playlist = {}
    @current_id = null
    @repeat = repeat: false, single: false
    @is_playing = false
    @seekto = null

    @mpd_is_playing = false
    @mpd_should_be_playing_id = null

    @parser.sendRequest "clear"
    @elapsed_anchor =
      value: 0
      timestamp: new Date

  refreshMpdStatus: !->
    @parser.sendRequest @parser.current_song_and_status_command, (o) ~>
      mpd_was_playing = @mpd_is_playing
      @mpd_is_playing = o.state is \play
      if mpd_was_playing and not @mpd_is_playing
        # reached the end of the song
        # TODO go to next song instead of stopping
        @is_playing = false
        @playlistChanged!

  createClient: (socket, permissions) ->
    # TODO: encapsulate client object
    client = socket
    client.permissions = permissions
    socket.on \request, !(request) ~>
      request = JSON.parse request
      @request client, request.cmd, !(arg) ~>
        response = JSON.stringify {callback_id: request.callback_id} <<< arg
        socket.emit \PlayerResponse, response
    # TODO: clean up these listeners when the socket disconnects
    @on \status, !(arg) ~> try socket.emit \PlayerStatus, JSON.stringify arg
    @on \error,  !(msg) ~> try socket.emit \MpdError, msg

    socket.emit 'Permissions', JSON.stringify(permissions)
    @on 'password', !(pass) ~>
      if success = (ref = @authenticate(pass))?
        client.permissions := ref
      socket.emit 'Permissions', JSON.stringify(client.permissions)
      socket.emit 'PasswordResult', JSON.stringify(success)

    return client

  request: !(client, request, cb=->) ->
    ~function check_permission (name)
      permission = command_permissions[name]
      return true if permission is null
      return true if client.permissions[permission]
      err = "command #{JSON.stringify name} requires permission #{JSON.stringify permission}"
      console.warn "permissions error:", err
      cb {err}
      return false

    if typeof request is 'object'
      # new-style command is an object
      {name} = request
      return unless check_permission name
      suppress_reply = false
      reply_object = null
      switch name
        case \listallinfo
          suppress_reply = true
          @library.get_library (library) -> cb {msg: library}
        case \password then @emit \password, request.password

        case \playlistinfo
          reply_object = @playlist
        case \currentsong
          reply_object = @current_id
        case \status
          reply_object =
            volume: null
            repeat: @repeat.repeat
            single: @repeat.single
            state: if @is_playing then 'play' else 'pause'
            elapsed_anchor: @elapsed_anchor

        case \addid
          for {file, pos} of request.items
            @playlist[pos] = file
          @playlistChanged!
        case \deleteid
          for id of request.ids
            delete @playlist[id]
          @playlistChanged!
        case \move
          for {id, pos} of request.items
            @playlist[pos] = delete @playlist[id]
          @playlistChanged!
        case \clear
          @playlist = {}
          @playlistChanged!
        case \shuffle
          void # TODO

        case \repeat
          @repeat.repeat = request.repeat
          @repeat.single = request.single
        case \play
          @current_id ?= @playlist[0]?.id
          @is_playing = true
          @playlistChanged!
        case \pause
          @is_playing = false
          @playlistChanged!
        case \stop
          @is_playing = false
          @seekto = 0
          @playlistChanged!
        case \next, \previous
          void # TODO use playid instead of next/previous
        case \playid
          @current_id = request.track_id
          @seekto = 0
          @is_playing = true
          @playlistChanged!
        default throw new Error "invalid command #{JSON.stringify name}"
      unless suppress_reply
        if reply_object? then cb {msg: reply_object} else cb {}

    else
      # old code still uses mpd string commands.
      # check permissions
      name = request.split(/\s/)[0]
      if name is 'command_list_begin'
        commands = request.split('\n')
        commands.shift!
        commands.pop!
        for command of commands
          name = command.split(/\s/)[0]
          return unless check_permission name
      else
        return unless check_permission name
      @parser.sendRequest request, cb

  playlistChanged: !->
    unless @playlist[@current_id]?
      # stopped
      @current_id = null
      @is_playing = false
      @seekto = 0
    if @seekto?
      # TODO
      @seekto = null
    commands = []
    if @is_playing
      unless @current_id is @mpd_should_be_playing_id
        # start mpd playing
        commands.push "clear"
        commands.push "addid \"#{qEscape @playlist[@current_id]}\""
        commands.push "play"
        @mpd_should_be_playing_id = @current_id
    else
      if @mpd_should_be_playing_id?
        # stop mpd
        commands.push "clear"
        @mpd_should_be_playing_id = null
    if commands.length
      if commands.length > 1
        commands.unshift "command_list_begin"
        commands.push "command_list_end"
      @parser.sendRequest commands.join "\n"
    @emit \status, <[playlist player]>
