const
  fs = require 'fs'
  http = require 'http'
  net = require 'net'
  socketio = require 'socket.io'
  socketio_client = require 'socket.io-client'
  express = require 'express'
  path = require 'path'
  assert = require 'assert'
  mkdirp = require 'mkdirp'
  PlayerClient = require './playerclient'
  MpdParser = require './mpdparser'
  PlayerServer = require './playerserver'
  async = require 'async'
  which = require 'which'
  Library = require './library'
  MpdConf = require './mpdconf'
  Killer = require './killer'
  spawn = require('child_process').spawn
  {EventEmitter} = require 'events'

process.env.NODE_ENV ||= "dev"

const
  HOST = process.env.HOST or "0.0.0.0"
  PORT = parseInt(process.env.PORT, 10) or 16242
  RUN_DIR = "run"
  MPD_SOCKET_PATH = path.join(RUN_DIR, "mpd.socket")
  STATE_FILE = path.join(RUN_DIR, "state.json")
  MPD_CONF_PATH = path.join(RUN_DIR, "mpd.conf")
  MPD_PID_FILE = path.join(RUN_DIR, "mpd.pid")


mpd_conf = MpdConf() # default
mpd_conf.setRunDir(RUN_DIR)
player_server = null
my_player = null
state = null
app = null
io = null

plugins =
  objects: {}
  bus: new EventEmitter()
  initialize: !(cb) ->
    const PLUGIN_PATH = path.join(__dirname, "plugins")
    fs.readdir PLUGIN_PATH, !(err, files) ~>
      return cb(err) if err
      for file of files
        continue unless /\.js$/.test(file)
        name = path.basename(file, ".js")
        Plugin = require("./plugins/#name")
        plugin = @objects[name] = new Plugin(@bus)
        plugin.on \state_changed, saveState
        plugin.on \status_changed, saveAndSendStatus
      cb()
  featuresList: ->
    ([name, plugin.is_enabled] for name, plugin in @objects)

const library = Library plugins.bus

!function makeRunDir (cb)
  mkdirp(RUN_DIR, cb)

const STATE_VERSION = 4 # increment this when layout of state object changes

const DEFAULT_PERMISSIONS =
  read: true
  add: true
  control: true
  # admin: true

!function initState (cb)
  which 'mpd', !(err, mpd_exe) ->
    # it's ok if we can't find the mpd binary right now.
    if err then console.warn "Unable to find mpd binary in path: #{err.stack}"
    state :=
      state_version: STATE_VERSION
      mpd_exe_path: mpd_exe
      status: {} # this structure is visible to clients
      mpd_conf: mpd_conf.state
      permissions: {}
      default_permissions: DEFAULT_PERMISSIONS
    cb()

!function startSocketIo
  app := express()
  app.disable('x-powered-by')

  app_server = http.createServer(app)

  if io?
    try io.server.close!
  io := socketio.listen(app_server)
  io.set 'log level', 2
  io.sockets.on 'connection', onSocketIoConnection

  app_server.listen PORT, HOST, !->
    process.send?('online')
    console.info "Listening at http://#HOST:#PORT"
    connectMasterPlayer!
  app_server.on \close, !->
    console.info "server closed"

  process.on 'message', !(message) ->
    if message is 'shutdown'
      process.exit(0)

!function startPlugins
  console.log 'starting plugins'
  app.use(express.static(path.join(__dirname, '../public')))
  app.use(express.static(path.join(__dirname, '../src/public')))
  plugins.bus.emit \app, app
  plugins.bus.emit \mpd, my_player
  plugins.bus.emit \save_state, state
  for [name, enabled] of plugins.featuresList()
    if enabled
      console.info "#{name} is enabled."
    else
      console.warn "#{name} is disabled."

function oncePerEventLoopFunc (fn)
  queued = false
  cbs = []
  !(cb) ->
    cbs.push(cb) if cb?
    return if queued
    queued := true
    process.nextTick !->
      queued := false
      fn !->
        cb(...) for cb of cbs

const saveState = oncePerEventLoopFunc !(cb) ->
  plugins.bus.emit \save_state, state
  fs.writeFile STATE_FILE, JSON.stringify(state, null, 4), "utf8", !(err) ->
    if err then console.error "Error saving state to disk: #{err.stack}"
    cb(err)

!function restoreState (cb)
  fs.readFile STATE_FILE, \utf8, !(err, data) ->
    if err?code is \ENOENT
      console.warn "No state file. Creating a new one."
    else if err
      return cb(err)
    else
      try
        loaded_state = JSON.parse(data)
      catch e
        return cb(new Error("state file contains invalid JSON: #e"))
      if loaded_state.state_version is not STATE_VERSION
        return cb(new Error("State version is #{loaded_state.state_version} but should be #STATE_VERSION"))

      state := loaded_state

    # have the plugins restore and then save to delete values that should not
    # have been restored.
    plugins.bus.emit \restore_state, state
    plugins.bus.emit \save_state, state

    cb()

!function saveAndSendStatus
  saveState()
  io.sockets.emit 'Status', JSON.stringify state.status

!function writeMpdConf (cb)
  mpd_conf := new MpdConf(state.mpd_conf)
  state.mpd_conf = mpd_conf.state
  fs.writeFile MPD_CONF_PATH, mpd_conf.toMpdConf(), cb

!function onSocketIoConnection (socket)
  client = player_server.createClient socket, state.default_permissions
  plugins.bus.emit \socket_connect, client

!function restartMpd (cb)
  mkdirp mpd_conf.playlistDirectory(), !(err) ->
    return cb(err) if err
    fs.readFile MPD_PID_FILE, 'utf8', !(err, pid_str) ->
      if err
        if err?code is \ENOENT
          startMpd(cb)
        else
          cb(err)
      else
        # need to kill mpd
        pid = parseInt(pid_str, 10)
        console.info "killing mpd", pid
        killer = Killer(pid)
        killer.on \error, !(err) -> cb(err)
        killer.on \end, !-> startMpd(cb)
        killer.kill()

!function startMpd(cb)
  console.info "starting mpd", state.mpd_exe_path
  child = spawn state.mpd_exe_path, [
    '--no-daemon'
    MPD_CONF_PATH
  ], {
    stdio: 'inherit'
    detached: true
  }
  cb()

function makeConnectFunction (name, {createSocket, onSuccess})
  connect_timeout = null
  !function tryReconnect
    return if connect_timeout?
    connect_timeout := setTimeout((!->
      connect_timeout := null
      connect!
    ), 1000)
  # start this as true so that we complain abuot the first sign of trouble
  connect_success = true
  !function connect
    socket = createSocket!
    socket.on \close, !->
      if connect_success
        console.warn "#name connection closed"
      tryReconnect!
    socket.on \error, !->
      if connect_success
        connect_success := false
        console.warn "#name connection error..."
      tryReconnect!
    socket.on \connect, !->
      console.log "#{if connect_success then '' else '...'}#name connected"
      connect_success := true
      onSuccess socket

const connectToMpd = makeConnectFunction 'mpd', {
  createSocket: ->
    socket = net.connect {path: MPD_SOCKET_PATH}
    socket.setEncoding 'utf8'
    socket
  onSuccess: !(socket) ->
    mpd_parser = MpdParser socket
    authenticate = (pass) -> state.permissions[pass]
    player_server := PlayerServer library, mpd_parser, authenticate
    startSocketIo!
}

const connectMasterPlayer = makeConnectFunction 'master player', {
  createSocket: ->
    socketio_client.connect "http://localhost:#PORT"
  onSuccess: !(socket) ->
    my_player := PlayerClient socket
    my_player.on \MpdError, !(msg) -> console.error msg
    socket.emit \SetUserName, '[server]'
    my_player.authenticate state.admin_password
    startPlugins!
}

async.series [
  initState
  makeRunDir
  plugins~initialize
  restoreState
  writeMpdConf
  # we always restart mpd so that it uses the mpd.conf we just generated
  restartMpd
], !(err) ->
  assert.ifError(err)
  connectToMpd!

