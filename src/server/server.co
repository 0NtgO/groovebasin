const
  fs = require 'fs'
  http = require 'http'
  net = require 'net'
  socketio = require 'socket.io'
  socketio_client = require 'socket.io-client'
  express = require 'express'
  path = require 'path'
  assert = require 'assert'
  mkdirp = require 'mkdirp'
  Player = require './player'
  MpdParser = require './mpdparser'
  PlayerServer = require './playerserver'
  async = require 'async'
  which = require 'which'
  Library = require './library'
  MpdConf = require './mpdconf'
  Killer = require './killer'
  spawn = require('child_process').spawn
  {EventEmitter} = require 'events'

process.env.NODE_ENV ||= "dev"

const
  HOST = process.env.HOST or "0.0.0.0"
  PORT = parseInt(process.env.PORT, 10) or 16242
  RUN_DIR = "run"
  MPD_SOCKET_PATH = path.join(RUN_DIR, "mpd.socket")
  STATE_FILE = path.join(RUN_DIR, "state.json")
  MPD_CONF_PATH = path.join(RUN_DIR, "mpd.conf")
  MPD_PID_FILE = path.join(RUN_DIR, "mpd.pid")


mpd_conf = MpdConf() # default
mpd_conf.setRunDir(RUN_DIR)
mpd_parser = null
my_player = null
mpd_connect_success = false
state = null
app = null
io = null

plugins =
  objects: {}
  bus: new EventEmitter()
  initialize: !(cb) ->
    const PLUGIN_PATH = path.join(__dirname, "plugins")
    fs.readdir PLUGIN_PATH, !(err, files) ~>
      return cb(err) if err
      for file of files
        continue unless /\.js$/.test(file)
        name = path.basename(file, ".js")
        Plugin = require("./plugins/#name")
        plugin = @objects[name] = new Plugin(@bus)
        plugin.on \state_changed, saveState
        plugin.on \status_changed, saveAndSendStatus
      cb()
  featuresList: ->
    ([name, plugin.is_enabled] for name, plugin in @objects)

library = Library plugins.bus
player_servers = {}
next_player_server_id = 0

!function makeRunDir (cb)
  mkdirp(RUN_DIR, cb)

const STATE_VERSION = 4 # increment this when layout of state object changes

const DEFAULT_PERMISSIONS =
  read: true
  add: true
  control: true
  # admin: true

!function initState (cb)
  which 'mpd', !(err, mpd_exe) ->
    # it's ok if we can't find the mpd binary right now.
    if err then console.warn "Unable to find mpd binary in path: #{err.stack}"
    state :=
      state_version: STATE_VERSION
      mpd_exe_path: mpd_exe
      status: {} # this structure is visible to clients
      mpd_conf: mpd_conf.state
      permissions: {}
      default_permissions: DEFAULT_PERMISSIONS
    cb()

async.series [
  initState
  makeRunDir
  plugins~initialize
  restoreState
  writeMpdConf
  # we always restart mpd so that it uses the mpd.conf we just generated
  restartMpd
], !(err) ->
  assert.ifError(err)
  connectToMpd!

!function startSocketIo
  app := express()
  app.disable('x-powered-by')

  app_server = http.createServer(app)

  if io?
    try io.server.close!
  io := socketio.listen(app_server)
  io.set 'log level', 2
  io.sockets.on 'connection', onSocketIoConnection

  app_server.listen PORT, HOST, !->
    process.send 'online'
    console.info "Listening at http://#HOST:#PORT"
  app_server.on \close, !->
    console.info "server closed"

  process.on 'message', onProcessMessage

  connectMasterPlayer!

!function startPlugins
  console.log 'starting plugins'
  app.use(express.static(path.join(__dirname, '../public')))
  app.use(express.static(path.join(__dirname, '../src/public')))
  plugins.bus.emit \app, app
  plugins.bus.emit \mpd, my_player
  plugins.bus.emit \save_state, state
  for [name, enabled] of plugins.featuresList()
    if enabled
      console.info "#{name} is enabled."
    else
      console.warn "#{name} is disabled."

function oncePerEventLoopFunc (fn)
  queued = false
  cbs = []
  !(cb) ->
    cbs.push(cb) if cb?
    return if queued
    queued := true
    process.nextTick !->
      queued := false
      fn !->
        cb(...) for cb of cbs

const saveState = oncePerEventLoopFunc !(cb) ->
  plugins.bus.emit \save_state, state
  fs.writeFile STATE_FILE, JSON.stringify(state, null, 4), "utf8", !(err) ->
    if err then console.error "Error saving state to disk: #{err.stack}"
    cb(err)

!function restoreState (cb)
  fs.readFile STATE_FILE, \utf8, !(err, data) ->
    if err?code is \ENOENT
      console.warn "No state file. Creating a new one."
    else if err
      return cb(err)
    else
      try
        loaded_state = JSON.parse(data)
      catch e
        return cb(new Error("state file contains invalid JSON: #e"))
      if loaded_state.state_version is not STATE_VERSION
        return cb(new Error("State version is #{loaded_state.state_version} but should be #STATE_VERSION"))

      state := loaded_state

    # have the plugins restore and then save to delete values that should not
    # have been restored.
    plugins.bus.emit \restore_state, state
    plugins.bus.emit \save_state, state

    cb()

!function sendStatus
  plugins.bus.emit \status_sent, state.status
  io.sockets.emit 'Status', JSON.stringify state.status

!function saveAndSendStatus
  saveState()
  sendStatus()

!function writeMpdConf (cb)
  mpd_conf := new MpdConf(state.mpd_conf)
  state.mpd_conf = mpd_conf.state
  fs.writeFile MPD_CONF_PATH, mpd_conf.toMpdConf(), cb

!function onSocketIoConnection (socket)
  permissions = state.default_permissions
  server = PlayerServer library, mpd_parser, -> permissions
  player_servers[id = next_player_server_id++] = server
  socket.on \disconnect, !->
    delete player_servers[id]

  socket.on \request, !(request) ->
    request = JSON.parse request
    server.request request.cmd, !(arg) ->
      response = JSON.stringify {callback_id: request.callback_id} <<< arg
      socket.emit \MpdResponse, response
  server.on \status, !(arg) -> try socket.emit \MpdStatus, JSON.stringify arg
  server.on \error,  !(msg) -> try socket.emit \MpdError, msg

  plugins.bus.emit \socket_connect, socket, -> permissions
  socket.emit 'Permissions', JSON.stringify(permissions)
  server.on 'password', !(pass) ->
    if success = (ref = state.permissions[pass])?
      permissions := ref
    socket.emit 'Permissions', JSON.stringify(permissions)
    socket.emit 'PasswordResult', JSON.stringify(success)

!function restartMpd (cb)
  mkdirp mpd_conf.playlistDirectory(), !(err) ->
    return cb(err) if err
    fs.readFile MPD_PID_FILE, 'utf8', !(err, pid_str) ->
      if err
        if err?code is \ENOENT
          startMpd(cb)
        else
          cb(err)
      else
        # need to kill mpd
        pid = parseInt(pid_str, 10)
        console.info "killing mpd", pid
        killer = Killer(pid)
        killer.on \error, !(err) -> cb(err)
        killer.on \end, !-> startMpd(cb)
        killer.kill()

!function startMpd(cb)
  console.info "starting mpd", state.mpd_exe_path
  child = spawn state.mpd_exe_path, [
    '--no-daemon'
    MPD_CONF_PATH
  ], {
    stdio: 'inherit'
    detached: true
  }
  cb()

function makeTryReconnect (fn, delay)
  connect_timeout = null
  ->
    return unless connect_timeout!?
    console.log 'attempting to connect to something'
    connect_timeout := setTimeout((!->
      connect_timeout := null
      fn!
    ), 1000)

const tryReconnectMpd = makeTryReconnect connectToMpd, 1000
!function connectToMpd
  socket = net.connect {path: MPD_SOCKET_PATH}
  socket.setEncoding 'utf8'
  socket.on 'close', !->
    if mpd_connect_success
      console.warn "mpd disconnect"
    tryReconnectMpd!
  socket.on 'error', !->
    if mpd_connect_success
      mpd_connect_success := false
      console.warn "no mpd daemon found."
    tryReconnectMpd!
  mpd_parser := MpdParser socket
  mpd_parser.on \lifesigns, !->
    console.info "connected to mpd"
    mpd_connect_success := true
    startSocketIo!

master_player_connect_success = false
const tryReconnectMasterPlayer = makeTryReconnect connectMasterPlayer, 100
!function connectMasterPlayer
  socket = socketio_client.connect "http://localhost:#PORT"
  my_player := Player socket
  my_player.on \MpdError, !(msg) -> console.error msg

  socket.on \close, !->
    if master_player_connect_success
      console.warn 'server player closed'
    tryReconnectMasterPlayer!
  socket.on \error, !(err) ->
    if master_player_connect_success
      console.warn 'server player error:', err
    tryReconnectMasterPlayer!
  socket.on \connect, !->
    console.log 'server player connected'
    master_player_connect_success := true
    socket.emit \SetUserName, '[server]'
    my_player.authenticate state.admin_password
    startPlugins!


function arrayToSet (array)
  obj = {}
  obj[item] = true for item of array
  obj

!function onProcessMessage (message)
  if message is 'shutdown'
    process.exit(0)

